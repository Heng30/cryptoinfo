use crate::qobjmgr::{qobj, NodeType as QNodeType};
use ::log::{debug, warn};
use modeldata::*;
use platform_dirs::AppDirs;
use qmetaobject::prelude::*;
use qmetaobject::QObjectPinned;
use std::fs;
use std::path::Path;
use NoteItem as Item;

#[derive(QGadget, Clone, Default)]
pub struct NoteItem {
    name: qt_property!(QString),
}

modeldata_struct!(Model, Item, members: {
        dir: String,
    }, members_qt: {
        text: [QString; text_changed],
    }, signals_qt: {
    }, methods_qt: {
        load_qml: fn(&mut self, index: i32),
        save_qml: fn(&mut self, index: i32, text: QString),
    }
);

impl Model {
    pub fn init(&mut self) {
        let app_dirs = qobj::<AppDirs>(QNodeType::AppDir);
        self.dir = app_dirs
            .data_dir
            .join("notes")
            .to_str()
            .unwrap()
            .to_string();
        self.load_names();
    }

    fn load_names(&mut self) {
        let dir = Path::new(&self.dir);
        if !dir.exists() {
            return;
        }

        match fs::read_dir(&dir) {
            Err(e) => debug!("{:?}", e),
            Ok(dirs) => {
                for entry in dirs {
                    match entry {
                        Err(e) => debug!("{:?}", e),
                        Ok(entry) => match entry.file_name().into_string() {
                            Err(e) => debug!("{:?}", e),
                            Ok(name) => {
                                let v = name.split('.').collect::<Vec<_>>();
                                if v.len() != 2 {
                                    continue;
                                }

                                self.append(Item {
                                    name: v[0].to_string().into(),
                                });
                            }
                        },
                    }
                }
            }
        }
    }

    fn load_qml(&mut self, index: i32) {
        if index < 0 || index as usize >= self.items_len() {
            return;
        }

        let index = index as usize;
        let path = self.dir.clone() + "/" + &self.items()[index].name.to_string() + ".md";

        match std::fs::read_to_string(&path) {
            Ok(text) => {
                self.text = text.into();
                self.text_changed();
            }
            Err(e) => debug!("{:?}", e),
        }
    }

    fn save_qml(&mut self, index: i32, text: QString) {
        if index < 0 || index as usize >= self.items_len() {
            return;
        }

        let index = index as usize;
        let path = self.dir.clone() + "/" + &self.items()[index].name.to_string() + ".md";

        if let Err(_) = fs::write(&path, self.text.to_string()) {
            warn!("save {:?} failed", &path);
        }
    }
}
